import { execSync } from "node:child_process";
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const dirname = path.dirname(fileURLToPath(import.meta.url));
const baseDir = path.resolve(dirname, "..");

const PROTO_DIR = path.resolve(baseDir, "src/api/proto");
const OUT_DIR = path.resolve(baseDir, "src/api/messages");

(async () => {
  console.log("Starting proto generation…");

  const protoFiles = findFiles(PROTO_DIR, /\.proto$/);

  if (protoFiles.length === 0) {
    console.error(`✗ No "*.proto" files found in ${PROTO_DIR}`);
    process.exit(1);
  }

  resetGeneratedFiles();
  // apply SDK specific patches to proto files before proto > ts generation
  patchProtoFiles(protoFiles);
  generateProtoFiles(protoFiles);
  // formatting before patching to make sure that generated code matches expected style
  // to correctly apply our regex-based patches
  formatGeneratedFiles();
  await addLintIgnoreToGeneratedFiles();
  // formatting after patching to make sure that generated code matches expected style
  formatGeneratedFiles();

  console.log("✓ Proto generation complete!");
})();

function resetGeneratedFiles() {
  if (fs.existsSync(OUT_DIR)) {
    console.log(`Removing existing generated files in ${OUT_DIR}…`);

    execSync(`rm -rf ${OUT_DIR}/*`);

    console.log(`✓ Removed existing generated files in ${OUT_DIR}`);
  } else {
    console.log(`Output directory ${OUT_DIR} does not exist, creating it now.`);

    execSync(`mkdir -p ${OUT_DIR}`);
  }
}

function patchProtoFiles(files) {
  try {
    console.log(`Patching proto files…`);

    /**
     * Replace `bytes` fields with `repeated uint32` for JSON-RPC compatibility.
     *
     * The JSON-RPC server serializes `bytes` fields as arrays of numbers rather than
     * as byte strings. To ensure proper type compatibility, we convert `bytes` types
     * to `repeated uint32` in the proto definitions.
     *
     * This transformation converts:
     * ```
     *   bytes field_name = 1;
     * ```
     *
     * Into:
     * ```
     *   repeated uint32 field_name = 1;
     * ```
     */
    function replaceBytes(fileContent) {
      return fileContent.replace(
        /(\s+)(bytes)(\s+\w+\s*=\s*\d+;)/g,
        (_match, p1, _p2, p3) => `${p1}repeated uint32${p3}`,
      );
    }

    for (const filePath of files) {
      let fileContent = fs.readFileSync(filePath, "utf-8");

      fileContent = [replaceBytes].reduce(
        (content, transform) => transform(content),
        fileContent,
      );

      fs.writeFileSync(filePath, fileContent, "utf-8");
    }
  } catch (error) {
    console.error("✗ Failed to patch proto files", error);

    process.exit(1);
  }
}

function generateProtoFiles(files) {
  try {
    console.log(`Generating proto files…`);

    execSync(
      [
        "protoc",
        `--plugin=${path.resolve(baseDir, "node_modules/.bin/protoc-gen-ts_proto")}`,
        `--ts_proto_out=${OUT_DIR}`,
        // see https://github.com/stephenh/ts-proto?tab=readme-ov-file#supported-options
        `--ts_proto_opt=${[
          "esModuleInterop=true",
          "outputEncodeMethods=false",
          "snakeToCamel=keys",
          "useNumericEnumForJson=true",
          "stringEnums=true",
          "emitDefaultValues=json-methods",
          "outputServices=false",
          "enumsAsLiterals=true",
        ].join(",")}`,
        `--proto_path=${PROTO_DIR}`,
        ...files,
      ].join(" "),
      { stdio: "inherit" },
    );

    console.log("✓ Proto files generated successfully");
  } catch (error) {
    console.error("✗ Failed to generate proto files", error);

    process.exit(1);
  }
}

function formatGeneratedFiles() {
  try {
    console.log("Formatting generated files…");

    execSync(`pnpm biome check --fix "${OUT_DIR}"`, {
      stdio: "inherit",
    });

    console.log("✓ Formatted generated files successfully");
  } catch (error) {
    console.error("✗ Failed to format generated files", error);

    process.exit(1);
  }
}

async function addLintIgnoreToGeneratedFiles() {
  try {
    console.log("Adding lint ignore to generated files…");

    const generatedFiles = findFiles(OUT_DIR, /\.ts$/);

    const existingIgnoreComment = ["\n", "/* eslint-disable */"].join("\n");

    const patchedIgnoreComment = [
      "\n",
      "/* eslint-disable */",
      "//biome-ignore-all : autogenerated file, no need to check",
      "\n",
    ].join("\n");

    for (const filePath of generatedFiles) {
      let fileContent = await fs.promises.readFile(filePath, "utf-8");

      fileContent = fileContent.replace(
        existingIgnoreComment,
        patchedIgnoreComment,
      );

      await fs.promises.writeFile(filePath, fileContent, "utf-8");
    }

    console.log("✓ Added lint ignore to generated files successfully");
  } catch (error) {
    console.error("✗ Failed to add lint ignore to generated files", error);

    process.exit(1);
  }
}

function findFiles(dir, pattern, fileList = []) {
  const files = fs.readdirSync(dir);

  for (const file of files) {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory()) {
      findFiles(filePath, pattern, fileList);
    } else if (pattern.test(file)) {
      fileList.push(filePath);
    }
  }

  return fileList;
}
