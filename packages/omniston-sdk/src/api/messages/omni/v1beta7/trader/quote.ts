// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.0
//   protoc               v6.33.0
// source: omni/v1beta7/trader/quote.proto

/* eslint-disable */
//biome-ignore-all : autogenerated file, no need to check

import {
  Address,
  KeepAlive,
  SettlementMethod,
  settlementMethodFromJSON,
  settlementMethodToJSON,
  Unsubscribed,
} from "../types/common";
import { Quote, RequestSettlementParams } from "../types/quote";

export const protobufPackage = "omni.v1beta7";

/** Indicates that the's no valid quote corresponding to RFQ. */
export interface NoQuoteEvent {}

/** Server sends acknowledge immediately upon reception of QuoteRequest and generation of `rfq_id`. */
export interface QuoteRequestAck {
  /** ID of RFQ generated by the server (SHA-256 hex string). */
  rfqId: string;
}

export interface QuoteEvent {
  event: QuoteEvent_EventOneOf | undefined;
}

export interface QuoteEvent_EventOneOf {
  /** Represents an updated quote received from the server in response to a quote request. */
  quoteUpdated?: Quote | undefined;
  /** Indicates that the's no valid quote corresponding to RFQ. */
  noQuote?: NoQuoteEvent | undefined;
  /** Server sends acknowledge immediately upon reception of QuoteRequest and generation of `rfq_id`. */
  ack?: QuoteRequestAck | undefined;
  /** The service message to keep connection alive. */
  keepAlive?: KeepAlive | undefined;
  /** Service message indicating that a request for quote has expired. Used only in WebSockets API. */
  unsubscribed?: Unsubscribed | undefined;
}

export interface LimitOrderQuoteRequest {
  /** Blockchain-specific address of bid asset. */
  bidAssetAddress: Address | undefined;
  /** Blockchain-specific address of ask asset. */
  askAssetAddress: Address | undefined;
  /** The amount of bid asset the trader wants to pay, including all fees. */
  bidUnits: string;
  /** The amount of ask asset the trader wants to get after all fees. */
  askUnits: string;
  /** The address of referrer that will receive the fees. */
  referrerAddress: Address | undefined;
  /** The amount of fees required by the referrer in basis points (1/10000 or 0.01%) */
  referrerFeeBps: number;
  /**
   * The protocol limits settlement methods in quotes to specified methods.
   * Different combinations of bid & ask chains might support different methods.
   * For Limit Orders only Escrow and HTLC settlement methods are supported.
   */
  settlementMethods: SettlementMethod[];
  settlementParams: RequestSettlementParams | undefined;
}

export interface QuoteResponse {
  quote: Quote | undefined;
}

function createBaseNoQuoteEvent(): NoQuoteEvent {
  return {};
}

export const NoQuoteEvent: MessageFns<NoQuoteEvent> = {
  fromJSON(_: any): NoQuoteEvent {
    return {};
  },

  toJSON(_: NoQuoteEvent): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NoQuoteEvent>, I>>(
    base?: I,
  ): NoQuoteEvent {
    return NoQuoteEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NoQuoteEvent>, I>>(
    _: I,
  ): NoQuoteEvent {
    const message = createBaseNoQuoteEvent();
    return message;
  },
};

function createBaseQuoteRequestAck(): QuoteRequestAck {
  return { rfqId: "" };
}

export const QuoteRequestAck: MessageFns<QuoteRequestAck> = {
  fromJSON(object: any): QuoteRequestAck {
    return {
      rfqId: isSet(object.rfq_id) ? globalThis.String(object.rfq_id) : "",
    };
  },

  toJSON(message: QuoteRequestAck): unknown {
    const obj: any = {};
    if (message.rfqId !== undefined) {
      obj.rfq_id = message.rfqId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuoteRequestAck>, I>>(
    base?: I,
  ): QuoteRequestAck {
    return QuoteRequestAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuoteRequestAck>, I>>(
    object: I,
  ): QuoteRequestAck {
    const message = createBaseQuoteRequestAck();
    message.rfqId = object.rfqId ?? "";
    return message;
  },
};

function createBaseQuoteEvent(): QuoteEvent {
  return { event: undefined };
}

export const QuoteEvent: MessageFns<QuoteEvent> = {
  fromJSON(object: any): QuoteEvent {
    return {
      event: isSet(object.event)
        ? QuoteEvent_EventOneOf.fromJSON(object.event)
        : undefined,
    };
  },

  toJSON(message: QuoteEvent): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = QuoteEvent_EventOneOf.toJSON(message.event);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuoteEvent>, I>>(base?: I): QuoteEvent {
    return QuoteEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuoteEvent>, I>>(
    object: I,
  ): QuoteEvent {
    const message = createBaseQuoteEvent();
    message.event =
      object.event !== undefined && object.event !== null
        ? QuoteEvent_EventOneOf.fromPartial(object.event)
        : undefined;
    return message;
  },
};

function createBaseQuoteEvent_EventOneOf(): QuoteEvent_EventOneOf {
  return {
    quoteUpdated: undefined,
    noQuote: undefined,
    ack: undefined,
    keepAlive: undefined,
    unsubscribed: undefined,
  };
}

export const QuoteEvent_EventOneOf: MessageFns<QuoteEvent_EventOneOf> = {
  fromJSON(object: any): QuoteEvent_EventOneOf {
    return {
      quoteUpdated: isSet(object.quote_updated)
        ? Quote.fromJSON(object.quote_updated)
        : undefined,
      noQuote: isSet(object.no_quote)
        ? NoQuoteEvent.fromJSON(object.no_quote)
        : undefined,
      ack: isSet(object.ack) ? QuoteRequestAck.fromJSON(object.ack) : undefined,
      keepAlive: isSet(object.keep_alive)
        ? KeepAlive.fromJSON(object.keep_alive)
        : undefined,
      unsubscribed: isSet(object.unsubscribed)
        ? Unsubscribed.fromJSON(object.unsubscribed)
        : undefined,
    };
  },

  toJSON(message: QuoteEvent_EventOneOf): unknown {
    const obj: any = {};
    if (message.quoteUpdated !== undefined) {
      obj.quote_updated = Quote.toJSON(message.quoteUpdated);
    }
    if (message.noQuote !== undefined) {
      obj.no_quote = NoQuoteEvent.toJSON(message.noQuote);
    }
    if (message.ack !== undefined) {
      obj.ack = QuoteRequestAck.toJSON(message.ack);
    }
    if (message.keepAlive !== undefined) {
      obj.keep_alive = KeepAlive.toJSON(message.keepAlive);
    }
    if (message.unsubscribed !== undefined) {
      obj.unsubscribed = Unsubscribed.toJSON(message.unsubscribed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuoteEvent_EventOneOf>, I>>(
    base?: I,
  ): QuoteEvent_EventOneOf {
    return QuoteEvent_EventOneOf.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuoteEvent_EventOneOf>, I>>(
    object: I,
  ): QuoteEvent_EventOneOf {
    const message = createBaseQuoteEvent_EventOneOf();
    message.quoteUpdated =
      object.quoteUpdated !== undefined && object.quoteUpdated !== null
        ? Quote.fromPartial(object.quoteUpdated)
        : undefined;
    message.noQuote =
      object.noQuote !== undefined && object.noQuote !== null
        ? NoQuoteEvent.fromPartial(object.noQuote)
        : undefined;
    message.ack =
      object.ack !== undefined && object.ack !== null
        ? QuoteRequestAck.fromPartial(object.ack)
        : undefined;
    message.keepAlive =
      object.keepAlive !== undefined && object.keepAlive !== null
        ? KeepAlive.fromPartial(object.keepAlive)
        : undefined;
    message.unsubscribed =
      object.unsubscribed !== undefined && object.unsubscribed !== null
        ? Unsubscribed.fromPartial(object.unsubscribed)
        : undefined;
    return message;
  },
};

function createBaseLimitOrderQuoteRequest(): LimitOrderQuoteRequest {
  return {
    bidAssetAddress: undefined,
    askAssetAddress: undefined,
    bidUnits: "",
    askUnits: "",
    referrerAddress: undefined,
    referrerFeeBps: 0,
    settlementMethods: [],
    settlementParams: undefined,
  };
}

export const LimitOrderQuoteRequest: MessageFns<LimitOrderQuoteRequest> = {
  fromJSON(object: any): LimitOrderQuoteRequest {
    return {
      bidAssetAddress: isSet(object.bid_asset_address)
        ? Address.fromJSON(object.bid_asset_address)
        : undefined,
      askAssetAddress: isSet(object.ask_asset_address)
        ? Address.fromJSON(object.ask_asset_address)
        : undefined,
      bidUnits: isSet(object.bid_units)
        ? globalThis.String(object.bid_units)
        : "",
      askUnits: isSet(object.ask_units)
        ? globalThis.String(object.ask_units)
        : "",
      referrerAddress: isSet(object.referrer_address)
        ? Address.fromJSON(object.referrer_address)
        : undefined,
      referrerFeeBps: isSet(object.referrer_fee_bps)
        ? globalThis.Number(object.referrer_fee_bps)
        : 0,
      settlementMethods: globalThis.Array.isArray(object?.settlement_methods)
        ? object.settlement_methods.map((e: any) => settlementMethodFromJSON(e))
        : [],
      settlementParams: isSet(object.settlement_params)
        ? RequestSettlementParams.fromJSON(object.settlement_params)
        : undefined,
    };
  },

  toJSON(message: LimitOrderQuoteRequest): unknown {
    const obj: any = {};
    if (message.bidAssetAddress !== undefined) {
      obj.bid_asset_address = Address.toJSON(message.bidAssetAddress);
    }
    if (message.askAssetAddress !== undefined) {
      obj.ask_asset_address = Address.toJSON(message.askAssetAddress);
    }
    if (message.bidUnits !== undefined) {
      obj.bid_units = message.bidUnits;
    }
    if (message.askUnits !== undefined) {
      obj.ask_units = message.askUnits;
    }
    if (message.referrerAddress !== undefined) {
      obj.referrer_address = Address.toJSON(message.referrerAddress);
    }
    if (message.referrerFeeBps !== undefined) {
      obj.referrer_fee_bps = Math.round(message.referrerFeeBps);
    }
    if (message.settlementMethods?.length) {
      obj.settlement_methods = message.settlementMethods.map((e) =>
        settlementMethodToJSON(e),
      );
    }
    if (message.settlementParams !== undefined) {
      obj.settlement_params = RequestSettlementParams.toJSON(
        message.settlementParams,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LimitOrderQuoteRequest>, I>>(
    base?: I,
  ): LimitOrderQuoteRequest {
    return LimitOrderQuoteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LimitOrderQuoteRequest>, I>>(
    object: I,
  ): LimitOrderQuoteRequest {
    const message = createBaseLimitOrderQuoteRequest();
    message.bidAssetAddress =
      object.bidAssetAddress !== undefined && object.bidAssetAddress !== null
        ? Address.fromPartial(object.bidAssetAddress)
        : undefined;
    message.askAssetAddress =
      object.askAssetAddress !== undefined && object.askAssetAddress !== null
        ? Address.fromPartial(object.askAssetAddress)
        : undefined;
    message.bidUnits = object.bidUnits ?? "";
    message.askUnits = object.askUnits ?? "";
    message.referrerAddress =
      object.referrerAddress !== undefined && object.referrerAddress !== null
        ? Address.fromPartial(object.referrerAddress)
        : undefined;
    message.referrerFeeBps = object.referrerFeeBps ?? 0;
    message.settlementMethods = object.settlementMethods?.map((e) => e) || [];
    message.settlementParams =
      object.settlementParams !== undefined && object.settlementParams !== null
        ? RequestSettlementParams.fromPartial(object.settlementParams)
        : undefined;
    return message;
  },
};

function createBaseQuoteResponse(): QuoteResponse {
  return { quote: undefined };
}

export const QuoteResponse: MessageFns<QuoteResponse> = {
  fromJSON(object: any): QuoteResponse {
    return {
      quote: isSet(object.quote) ? Quote.fromJSON(object.quote) : undefined,
    };
  },

  toJSON(message: QuoteResponse): unknown {
    const obj: any = {};
    if (message.quote !== undefined) {
      obj.quote = Quote.toJSON(message.quote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuoteResponse>, I>>(
    base?: I,
  ): QuoteResponse {
    return QuoteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuoteResponse>, I>>(
    object: I,
  ): QuoteResponse {
    const message = createBaseQuoteResponse();
    message.quote =
      object.quote !== undefined && object.quote !== null
        ? Quote.fromPartial(object.quote)
        : undefined;
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
