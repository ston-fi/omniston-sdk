// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.0
//   protoc               v6.33.0
// source: omni/v1beta7/trader/trade.proto

/* eslint-disable */
//biome-ignore-all : autogenerated file, no need to check

import { Address, KeepAlive, Unsubscribed } from "../types/common";

export const protobufPackage = "omni.v1beta7";

export const SwapChunkResult = {
  SWAP_CHUNK_RESULT_PROCESSING: "SWAP_CHUNK_RESULT_PROCESSING",
  SWAP_CHUNK_RESULT_FILLED: "SWAP_CHUNK_RESULT_FILLED",
  SWAP_CHUNK_RESULT_ABORTED: "SWAP_CHUNK_RESULT_ABORTED",
  UNRECOGNIZED: "UNRECOGNIZED",
} as const;

export type SwapChunkResult =
  (typeof SwapChunkResult)[keyof typeof SwapChunkResult];

export namespace SwapChunkResult {
  export type SWAP_CHUNK_RESULT_PROCESSING =
    typeof SwapChunkResult.SWAP_CHUNK_RESULT_PROCESSING;
  export type SWAP_CHUNK_RESULT_FILLED =
    typeof SwapChunkResult.SWAP_CHUNK_RESULT_FILLED;
  export type SWAP_CHUNK_RESULT_ABORTED =
    typeof SwapChunkResult.SWAP_CHUNK_RESULT_ABORTED;
  export type UNRECOGNIZED = typeof SwapChunkResult.UNRECOGNIZED;
}

export function swapChunkResultFromJSON(object: any): SwapChunkResult {
  switch (object) {
    case 0:
    case "SWAP_CHUNK_RESULT_PROCESSING":
      return SwapChunkResult.SWAP_CHUNK_RESULT_PROCESSING;
    case 1:
    case "SWAP_CHUNK_RESULT_FILLED":
      return SwapChunkResult.SWAP_CHUNK_RESULT_FILLED;
    case 2:
    case "SWAP_CHUNK_RESULT_ABORTED":
      return SwapChunkResult.SWAP_CHUNK_RESULT_ABORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SwapChunkResult.UNRECOGNIZED;
  }
}

export function swapChunkResultToJSON(object: SwapChunkResult): number {
  switch (object) {
    case SwapChunkResult.SWAP_CHUNK_RESULT_PROCESSING:
      return 0;
    case SwapChunkResult.SWAP_CHUNK_RESULT_FILLED:
      return 1;
    case SwapChunkResult.SWAP_CHUNK_RESULT_ABORTED:
      return 2;
    case SwapChunkResult.UNRECOGNIZED:
    default:
      return -1;
  }
}

export const TradeResult = {
  TRADE_RESULT_UNKNOWN: "TRADE_RESULT_UNKNOWN",
  TRADE_RESULT_FULLY_FILLED: "TRADE_RESULT_FULLY_FILLED",
  TRADE_RESULT_PARTIALLY_FILLED: "TRADE_RESULT_PARTIALLY_FILLED",
  TRADE_RESULT_ABORTED: "TRADE_RESULT_ABORTED",
  UNRECOGNIZED: "UNRECOGNIZED",
} as const;

export type TradeResult = (typeof TradeResult)[keyof typeof TradeResult];

export namespace TradeResult {
  export type TRADE_RESULT_UNKNOWN = typeof TradeResult.TRADE_RESULT_UNKNOWN;
  export type TRADE_RESULT_FULLY_FILLED =
    typeof TradeResult.TRADE_RESULT_FULLY_FILLED;
  export type TRADE_RESULT_PARTIALLY_FILLED =
    typeof TradeResult.TRADE_RESULT_PARTIALLY_FILLED;
  export type TRADE_RESULT_ABORTED = typeof TradeResult.TRADE_RESULT_ABORTED;
  export type UNRECOGNIZED = typeof TradeResult.UNRECOGNIZED;
}

export function tradeResultFromJSON(object: any): TradeResult {
  switch (object) {
    case 0:
    case "TRADE_RESULT_UNKNOWN":
      return TradeResult.TRADE_RESULT_UNKNOWN;
    case 1:
    case "TRADE_RESULT_FULLY_FILLED":
      return TradeResult.TRADE_RESULT_FULLY_FILLED;
    case 2:
    case "TRADE_RESULT_PARTIALLY_FILLED":
      return TradeResult.TRADE_RESULT_PARTIALLY_FILLED;
    case 3:
    case "TRADE_RESULT_ABORTED":
      return TradeResult.TRADE_RESULT_ABORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TradeResult.UNRECOGNIZED;
  }
}

export function tradeResultToJSON(object: TradeResult): number {
  switch (object) {
    case TradeResult.TRADE_RESULT_UNKNOWN:
      return 0;
    case TradeResult.TRADE_RESULT_FULLY_FILLED:
      return 1;
    case TradeResult.TRADE_RESULT_PARTIALLY_FILLED:
      return 2;
    case TradeResult.TRADE_RESULT_ABORTED:
      return 3;
    case TradeResult.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface SwapChunkStatus {
  protocol: string;
  /**
   * Address of the contract that processes this chunk.
   *
   * Generally, this address receives bid tokens.
   * More specifically, it might be the address of a protocol or liquidity pool.
   */
  targetAddress: Address | undefined;
  bidUnits: string;
  expectedAskUnits: string;
  actualAskUnits: string;
  result: SwapChunkResult;
  /** Hash of the transaction that performs swapping of the chunk. */
  txHash: string;
}

export interface SwapStepStatus {
  chunks: SwapChunkStatus[];
}

export interface SwapRouteStatus {
  steps: SwapStepStatus[];
}

export interface EscrowOrderStatus {
  targetAddress: Address | undefined;
  askUnits: string;
  /** Hash of the transaction that performs the payout */
  txHash: string;
}

/** A request to track the status of specific trade */
export interface TrackTradeRequest {
  /** ID of the quote */
  quoteId: string;
  /** The address of trader's wallet that initiated transaction */
  traderWalletAddress: Address | undefined;
  /** Hash of tx outgoing from the wallet */
  outgoingTxHash: string;
}

/**
 * Waiting for the trader to initiate the trade.
 * Getting this status means that the transaction initiating the trade hasn't appeared yet.
 */
export interface AwaitingTransfer {}

/** Initial transaction found, waiting for its mining. */
export interface Transferring {}

/**
 * Awaiting swap transactions in the DEX protocols.
 *
 * Specific to `SWAP` settlement method.
 */
export interface Swapping {
  /** Info about partial filling of the trade. */
  routes: SwapRouteStatus[];
}

/**
 * Awaiting resolver's deposit.
 *
 * Specific to `ESCROW` & `HTLC` settlement.
 *
 * **UNSTABLE:** This is unstable API, it's subject to backward-incompatible changes.
 */
export interface AwaitingFill {}

/**
 * Specific to `HTLC` settlement. Resolver's deposit is claimable.
 *
 * **UNSTABLE:** This is unstable API, it's subject to backward-incompatible changes.
 */
export interface ClaimAvailable {
  /** Address of HTLC contract with claimable deposit. */
  contractAddress: Address | undefined;
  /** Index of deposit within HTLC contract with claimable deposit. */
  depositIndex: number;
}

/**
 * Specific to `ESCROW` & `HTLC` settlement. Deposit timeout has expired, need to refund it.
 *
 * **UNSTABLE:** This is unstable API, it's subject to backward-incompatible changes.
 */
export interface RefundAvailable {
  /** Address of escrow or HTLC contract that enforces the swap. */
  contractAddress: Address | undefined;
}

/** The transactions with incoming funds found, waiting for them to mine. */
export interface ReceivingFunds {
  /** Specific to `SWAP` settlement. Info about chunks of the trade. */
  routes: SwapRouteStatus[];
}

/** The trade has completed (fully or partially filled or fully aborted) */
export interface TradeSettled {
  /** Result of the trade */
  result: TradeResult;
  /** Specific to `SWAP` settlement. Info about partial filling of the trade. */
  routes: SwapRouteStatus[];
  /** Specific to `Escrow` settlement. Info about filling of the trade. */
  escrowOrderStatus: EscrowOrderStatus | undefined;
}

export interface TradeStatus {
  status: TradeStatus_StatusOneOf | undefined;
  /**
   * Timestamp (UTC seconds) when outgoing transfer has been detected.
   *
   * This field contains zero until the transfer has been detected.
   */
  transferTimestamp: number;
  /**
   * Timestamp (UTC seconds) of completion of the trade.
   *
   * This field contains zero until the transfer has been detected.
   * For non-settled trades this field contains estimated timestamp of trade completion.
   * For settled trades this field contains the exact timestamp of last transaction of the trade.
   */
  estimatedFinishTimestamp: number;
}

export interface TradeStatus_StatusOneOf {
  /** Waiting for the trader to initiate the trade. */
  awaitingTransfer?: AwaitingTransfer | undefined;
  /** Initial transaction found, waiting for transfer of funds to complete. */
  transferring?: Transferring | undefined;
  /** Awaiting swap transactions in the DEX protocols. */
  swapping?: Swapping | undefined;
  /** Awaiting resolver's deposit. */
  awaitingFill?: AwaitingFill | undefined;
  /** Specific to `HTLC` settlement. Resolver's deposit is claimable. */
  claimAvailable?: ClaimAvailable | undefined;
  /** Specific to `ESCROW` & `HTLC` settlement. Deposit timeout has expired, need to refund it */
  refundAvailable?: RefundAvailable | undefined;
  /** The transaction with incoming funds found, waiting for it to mine. */
  receivingFunds?: ReceivingFunds | undefined;
  /** The trade has completed (fully or partially filled or fully aborted) */
  tradeSettled?: TradeSettled | undefined;
  /** The service message to keep connection alive */
  keepAlive?: KeepAlive | undefined;
  /** Service message indicating that a request for state has expired. Used only for WebSocket API */
  unsubscribed?: Unsubscribed | undefined;
}

function createBaseSwapChunkStatus(): SwapChunkStatus {
  return {
    protocol: "",
    targetAddress: undefined,
    bidUnits: "",
    expectedAskUnits: "",
    actualAskUnits: "",
    result: SwapChunkResult.SWAP_CHUNK_RESULT_PROCESSING,
    txHash: "",
  };
}

export const SwapChunkStatus: MessageFns<SwapChunkStatus> = {
  fromJSON(object: any): SwapChunkStatus {
    return {
      protocol: isSet(object.protocol)
        ? globalThis.String(object.protocol)
        : "",
      targetAddress: isSet(object.target_address)
        ? Address.fromJSON(object.target_address)
        : undefined,
      bidUnits: isSet(object.bid_units)
        ? globalThis.String(object.bid_units)
        : "",
      expectedAskUnits: isSet(object.expected_ask_units)
        ? globalThis.String(object.expected_ask_units)
        : "",
      actualAskUnits: isSet(object.actual_ask_units)
        ? globalThis.String(object.actual_ask_units)
        : "",
      result: isSet(object.result)
        ? swapChunkResultFromJSON(object.result)
        : SwapChunkResult.SWAP_CHUNK_RESULT_PROCESSING,
      txHash: isSet(object.tx_hash) ? globalThis.String(object.tx_hash) : "",
    };
  },

  toJSON(message: SwapChunkStatus): unknown {
    const obj: any = {};
    if (message.protocol !== undefined) {
      obj.protocol = message.protocol;
    }
    if (message.targetAddress !== undefined) {
      obj.target_address = Address.toJSON(message.targetAddress);
    }
    if (message.bidUnits !== undefined) {
      obj.bid_units = message.bidUnits;
    }
    if (message.expectedAskUnits !== undefined) {
      obj.expected_ask_units = message.expectedAskUnits;
    }
    if (message.actualAskUnits !== undefined) {
      obj.actual_ask_units = message.actualAskUnits;
    }
    if (message.result !== undefined) {
      obj.result = swapChunkResultToJSON(message.result);
    }
    if (message.txHash !== undefined) {
      obj.tx_hash = message.txHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapChunkStatus>, I>>(
    base?: I,
  ): SwapChunkStatus {
    return SwapChunkStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapChunkStatus>, I>>(
    object: I,
  ): SwapChunkStatus {
    const message = createBaseSwapChunkStatus();
    message.protocol = object.protocol ?? "";
    message.targetAddress =
      object.targetAddress !== undefined && object.targetAddress !== null
        ? Address.fromPartial(object.targetAddress)
        : undefined;
    message.bidUnits = object.bidUnits ?? "";
    message.expectedAskUnits = object.expectedAskUnits ?? "";
    message.actualAskUnits = object.actualAskUnits ?? "";
    message.result =
      object.result ?? SwapChunkResult.SWAP_CHUNK_RESULT_PROCESSING;
    message.txHash = object.txHash ?? "";
    return message;
  },
};

function createBaseSwapStepStatus(): SwapStepStatus {
  return { chunks: [] };
}

export const SwapStepStatus: MessageFns<SwapStepStatus> = {
  fromJSON(object: any): SwapStepStatus {
    return {
      chunks: globalThis.Array.isArray(object?.chunks)
        ? object.chunks.map((e: any) => SwapChunkStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SwapStepStatus): unknown {
    const obj: any = {};
    if (message.chunks?.length) {
      obj.chunks = message.chunks.map((e) => SwapChunkStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapStepStatus>, I>>(
    base?: I,
  ): SwapStepStatus {
    return SwapStepStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapStepStatus>, I>>(
    object: I,
  ): SwapStepStatus {
    const message = createBaseSwapStepStatus();
    message.chunks =
      object.chunks?.map((e) => SwapChunkStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSwapRouteStatus(): SwapRouteStatus {
  return { steps: [] };
}

export const SwapRouteStatus: MessageFns<SwapRouteStatus> = {
  fromJSON(object: any): SwapRouteStatus {
    return {
      steps: globalThis.Array.isArray(object?.steps)
        ? object.steps.map((e: any) => SwapStepStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SwapRouteStatus): unknown {
    const obj: any = {};
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => SwapStepStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapRouteStatus>, I>>(
    base?: I,
  ): SwapRouteStatus {
    return SwapRouteStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapRouteStatus>, I>>(
    object: I,
  ): SwapRouteStatus {
    const message = createBaseSwapRouteStatus();
    message.steps =
      object.steps?.map((e) => SwapStepStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEscrowOrderStatus(): EscrowOrderStatus {
  return { targetAddress: undefined, askUnits: "", txHash: "" };
}

export const EscrowOrderStatus: MessageFns<EscrowOrderStatus> = {
  fromJSON(object: any): EscrowOrderStatus {
    return {
      targetAddress: isSet(object.target_address)
        ? Address.fromJSON(object.target_address)
        : undefined,
      askUnits: isSet(object.ask_units)
        ? globalThis.String(object.ask_units)
        : "",
      txHash: isSet(object.tx_hash) ? globalThis.String(object.tx_hash) : "",
    };
  },

  toJSON(message: EscrowOrderStatus): unknown {
    const obj: any = {};
    if (message.targetAddress !== undefined) {
      obj.target_address = Address.toJSON(message.targetAddress);
    }
    if (message.askUnits !== undefined) {
      obj.ask_units = message.askUnits;
    }
    if (message.txHash !== undefined) {
      obj.tx_hash = message.txHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EscrowOrderStatus>, I>>(
    base?: I,
  ): EscrowOrderStatus {
    return EscrowOrderStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EscrowOrderStatus>, I>>(
    object: I,
  ): EscrowOrderStatus {
    const message = createBaseEscrowOrderStatus();
    message.targetAddress =
      object.targetAddress !== undefined && object.targetAddress !== null
        ? Address.fromPartial(object.targetAddress)
        : undefined;
    message.askUnits = object.askUnits ?? "";
    message.txHash = object.txHash ?? "";
    return message;
  },
};

function createBaseTrackTradeRequest(): TrackTradeRequest {
  return { quoteId: "", traderWalletAddress: undefined, outgoingTxHash: "" };
}

export const TrackTradeRequest: MessageFns<TrackTradeRequest> = {
  fromJSON(object: any): TrackTradeRequest {
    return {
      quoteId: isSet(object.quote_id) ? globalThis.String(object.quote_id) : "",
      traderWalletAddress: isSet(object.trader_wallet_address)
        ? Address.fromJSON(object.trader_wallet_address)
        : undefined,
      outgoingTxHash: isSet(object.outgoing_tx_hash)
        ? globalThis.String(object.outgoing_tx_hash)
        : "",
    };
  },

  toJSON(message: TrackTradeRequest): unknown {
    const obj: any = {};
    if (message.quoteId !== undefined) {
      obj.quote_id = message.quoteId;
    }
    if (message.traderWalletAddress !== undefined) {
      obj.trader_wallet_address = Address.toJSON(message.traderWalletAddress);
    }
    if (message.outgoingTxHash !== undefined) {
      obj.outgoing_tx_hash = message.outgoingTxHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackTradeRequest>, I>>(
    base?: I,
  ): TrackTradeRequest {
    return TrackTradeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackTradeRequest>, I>>(
    object: I,
  ): TrackTradeRequest {
    const message = createBaseTrackTradeRequest();
    message.quoteId = object.quoteId ?? "";
    message.traderWalletAddress =
      object.traderWalletAddress !== undefined &&
      object.traderWalletAddress !== null
        ? Address.fromPartial(object.traderWalletAddress)
        : undefined;
    message.outgoingTxHash = object.outgoingTxHash ?? "";
    return message;
  },
};

function createBaseAwaitingTransfer(): AwaitingTransfer {
  return {};
}

export const AwaitingTransfer: MessageFns<AwaitingTransfer> = {
  fromJSON(_: any): AwaitingTransfer {
    return {};
  },

  toJSON(_: AwaitingTransfer): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AwaitingTransfer>, I>>(
    base?: I,
  ): AwaitingTransfer {
    return AwaitingTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AwaitingTransfer>, I>>(
    _: I,
  ): AwaitingTransfer {
    const message = createBaseAwaitingTransfer();
    return message;
  },
};

function createBaseTransferring(): Transferring {
  return {};
}

export const Transferring: MessageFns<Transferring> = {
  fromJSON(_: any): Transferring {
    return {};
  },

  toJSON(_: Transferring): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Transferring>, I>>(
    base?: I,
  ): Transferring {
    return Transferring.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transferring>, I>>(
    _: I,
  ): Transferring {
    const message = createBaseTransferring();
    return message;
  },
};

function createBaseSwapping(): Swapping {
  return { routes: [] };
}

export const Swapping: MessageFns<Swapping> = {
  fromJSON(object: any): Swapping {
    return {
      routes: globalThis.Array.isArray(object?.routes)
        ? object.routes.map((e: any) => SwapRouteStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Swapping): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => SwapRouteStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Swapping>, I>>(base?: I): Swapping {
    return Swapping.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Swapping>, I>>(object: I): Swapping {
    const message = createBaseSwapping();
    message.routes =
      object.routes?.map((e) => SwapRouteStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAwaitingFill(): AwaitingFill {
  return {};
}

export const AwaitingFill: MessageFns<AwaitingFill> = {
  fromJSON(_: any): AwaitingFill {
    return {};
  },

  toJSON(_: AwaitingFill): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AwaitingFill>, I>>(
    base?: I,
  ): AwaitingFill {
    return AwaitingFill.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AwaitingFill>, I>>(
    _: I,
  ): AwaitingFill {
    const message = createBaseAwaitingFill();
    return message;
  },
};

function createBaseClaimAvailable(): ClaimAvailable {
  return { contractAddress: undefined, depositIndex: 0 };
}

export const ClaimAvailable: MessageFns<ClaimAvailable> = {
  fromJSON(object: any): ClaimAvailable {
    return {
      contractAddress: isSet(object.contract_address)
        ? Address.fromJSON(object.contract_address)
        : undefined,
      depositIndex: isSet(object.deposit_index)
        ? globalThis.Number(object.deposit_index)
        : 0,
    };
  },

  toJSON(message: ClaimAvailable): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contract_address = Address.toJSON(message.contractAddress);
    }
    if (message.depositIndex !== undefined) {
      obj.deposit_index = Math.round(message.depositIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimAvailable>, I>>(
    base?: I,
  ): ClaimAvailable {
    return ClaimAvailable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimAvailable>, I>>(
    object: I,
  ): ClaimAvailable {
    const message = createBaseClaimAvailable();
    message.contractAddress =
      object.contractAddress !== undefined && object.contractAddress !== null
        ? Address.fromPartial(object.contractAddress)
        : undefined;
    message.depositIndex = object.depositIndex ?? 0;
    return message;
  },
};

function createBaseRefundAvailable(): RefundAvailable {
  return { contractAddress: undefined };
}

export const RefundAvailable: MessageFns<RefundAvailable> = {
  fromJSON(object: any): RefundAvailable {
    return {
      contractAddress: isSet(object.contract_address)
        ? Address.fromJSON(object.contract_address)
        : undefined,
    };
  },

  toJSON(message: RefundAvailable): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contract_address = Address.toJSON(message.contractAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefundAvailable>, I>>(
    base?: I,
  ): RefundAvailable {
    return RefundAvailable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefundAvailable>, I>>(
    object: I,
  ): RefundAvailable {
    const message = createBaseRefundAvailable();
    message.contractAddress =
      object.contractAddress !== undefined && object.contractAddress !== null
        ? Address.fromPartial(object.contractAddress)
        : undefined;
    return message;
  },
};

function createBaseReceivingFunds(): ReceivingFunds {
  return { routes: [] };
}

export const ReceivingFunds: MessageFns<ReceivingFunds> = {
  fromJSON(object: any): ReceivingFunds {
    return {
      routes: globalThis.Array.isArray(object?.routes)
        ? object.routes.map((e: any) => SwapRouteStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReceivingFunds): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => SwapRouteStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceivingFunds>, I>>(
    base?: I,
  ): ReceivingFunds {
    return ReceivingFunds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceivingFunds>, I>>(
    object: I,
  ): ReceivingFunds {
    const message = createBaseReceivingFunds();
    message.routes =
      object.routes?.map((e) => SwapRouteStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTradeSettled(): TradeSettled {
  return {
    result: TradeResult.TRADE_RESULT_UNKNOWN,
    routes: [],
    escrowOrderStatus: undefined,
  };
}

export const TradeSettled: MessageFns<TradeSettled> = {
  fromJSON(object: any): TradeSettled {
    return {
      result: isSet(object.result)
        ? tradeResultFromJSON(object.result)
        : TradeResult.TRADE_RESULT_UNKNOWN,
      routes: globalThis.Array.isArray(object?.routes)
        ? object.routes.map((e: any) => SwapRouteStatus.fromJSON(e))
        : [],
      escrowOrderStatus: isSet(object.escrow_order_status)
        ? EscrowOrderStatus.fromJSON(object.escrow_order_status)
        : undefined,
    };
  },

  toJSON(message: TradeSettled): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = tradeResultToJSON(message.result);
    }
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => SwapRouteStatus.toJSON(e));
    }
    if (message.escrowOrderStatus !== undefined) {
      obj.escrow_order_status = EscrowOrderStatus.toJSON(
        message.escrowOrderStatus,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TradeSettled>, I>>(
    base?: I,
  ): TradeSettled {
    return TradeSettled.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TradeSettled>, I>>(
    object: I,
  ): TradeSettled {
    const message = createBaseTradeSettled();
    message.result = object.result ?? TradeResult.TRADE_RESULT_UNKNOWN;
    message.routes =
      object.routes?.map((e) => SwapRouteStatus.fromPartial(e)) || [];
    message.escrowOrderStatus =
      object.escrowOrderStatus !== undefined &&
      object.escrowOrderStatus !== null
        ? EscrowOrderStatus.fromPartial(object.escrowOrderStatus)
        : undefined;
    return message;
  },
};

function createBaseTradeStatus(): TradeStatus {
  return {
    status: undefined,
    transferTimestamp: 0,
    estimatedFinishTimestamp: 0,
  };
}

export const TradeStatus: MessageFns<TradeStatus> = {
  fromJSON(object: any): TradeStatus {
    return {
      status: isSet(object.status)
        ? TradeStatus_StatusOneOf.fromJSON(object.status)
        : undefined,
      transferTimestamp: isSet(object.transfer_timestamp)
        ? globalThis.Number(object.transfer_timestamp)
        : 0,
      estimatedFinishTimestamp: isSet(object.estimated_finish_timestamp)
        ? globalThis.Number(object.estimated_finish_timestamp)
        : 0,
    };
  },

  toJSON(message: TradeStatus): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = TradeStatus_StatusOneOf.toJSON(message.status);
    }
    if (message.transferTimestamp !== undefined) {
      obj.transfer_timestamp = Math.round(message.transferTimestamp);
    }
    if (message.estimatedFinishTimestamp !== undefined) {
      obj.estimated_finish_timestamp = Math.round(
        message.estimatedFinishTimestamp,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TradeStatus>, I>>(base?: I): TradeStatus {
    return TradeStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TradeStatus>, I>>(
    object: I,
  ): TradeStatus {
    const message = createBaseTradeStatus();
    message.status =
      object.status !== undefined && object.status !== null
        ? TradeStatus_StatusOneOf.fromPartial(object.status)
        : undefined;
    message.transferTimestamp = object.transferTimestamp ?? 0;
    message.estimatedFinishTimestamp = object.estimatedFinishTimestamp ?? 0;
    return message;
  },
};

function createBaseTradeStatus_StatusOneOf(): TradeStatus_StatusOneOf {
  return {
    awaitingTransfer: undefined,
    transferring: undefined,
    swapping: undefined,
    awaitingFill: undefined,
    claimAvailable: undefined,
    refundAvailable: undefined,
    receivingFunds: undefined,
    tradeSettled: undefined,
    keepAlive: undefined,
    unsubscribed: undefined,
  };
}

export const TradeStatus_StatusOneOf: MessageFns<TradeStatus_StatusOneOf> = {
  fromJSON(object: any): TradeStatus_StatusOneOf {
    return {
      awaitingTransfer: isSet(object.awaiting_transfer)
        ? AwaitingTransfer.fromJSON(object.awaiting_transfer)
        : undefined,
      transferring: isSet(object.transferring)
        ? Transferring.fromJSON(object.transferring)
        : undefined,
      swapping: isSet(object.swapping)
        ? Swapping.fromJSON(object.swapping)
        : undefined,
      awaitingFill: isSet(object.awaiting_fill)
        ? AwaitingFill.fromJSON(object.awaiting_fill)
        : undefined,
      claimAvailable: isSet(object.claim_available)
        ? ClaimAvailable.fromJSON(object.claim_available)
        : undefined,
      refundAvailable: isSet(object.refund_available)
        ? RefundAvailable.fromJSON(object.refund_available)
        : undefined,
      receivingFunds: isSet(object.receiving_funds)
        ? ReceivingFunds.fromJSON(object.receiving_funds)
        : undefined,
      tradeSettled: isSet(object.trade_settled)
        ? TradeSettled.fromJSON(object.trade_settled)
        : undefined,
      keepAlive: isSet(object.keep_alive)
        ? KeepAlive.fromJSON(object.keep_alive)
        : undefined,
      unsubscribed: isSet(object.unsubscribed)
        ? Unsubscribed.fromJSON(object.unsubscribed)
        : undefined,
    };
  },

  toJSON(message: TradeStatus_StatusOneOf): unknown {
    const obj: any = {};
    if (message.awaitingTransfer !== undefined) {
      obj.awaiting_transfer = AwaitingTransfer.toJSON(message.awaitingTransfer);
    }
    if (message.transferring !== undefined) {
      obj.transferring = Transferring.toJSON(message.transferring);
    }
    if (message.swapping !== undefined) {
      obj.swapping = Swapping.toJSON(message.swapping);
    }
    if (message.awaitingFill !== undefined) {
      obj.awaiting_fill = AwaitingFill.toJSON(message.awaitingFill);
    }
    if (message.claimAvailable !== undefined) {
      obj.claim_available = ClaimAvailable.toJSON(message.claimAvailable);
    }
    if (message.refundAvailable !== undefined) {
      obj.refund_available = RefundAvailable.toJSON(message.refundAvailable);
    }
    if (message.receivingFunds !== undefined) {
      obj.receiving_funds = ReceivingFunds.toJSON(message.receivingFunds);
    }
    if (message.tradeSettled !== undefined) {
      obj.trade_settled = TradeSettled.toJSON(message.tradeSettled);
    }
    if (message.keepAlive !== undefined) {
      obj.keep_alive = KeepAlive.toJSON(message.keepAlive);
    }
    if (message.unsubscribed !== undefined) {
      obj.unsubscribed = Unsubscribed.toJSON(message.unsubscribed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TradeStatus_StatusOneOf>, I>>(
    base?: I,
  ): TradeStatus_StatusOneOf {
    return TradeStatus_StatusOneOf.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TradeStatus_StatusOneOf>, I>>(
    object: I,
  ): TradeStatus_StatusOneOf {
    const message = createBaseTradeStatus_StatusOneOf();
    message.awaitingTransfer =
      object.awaitingTransfer !== undefined && object.awaitingTransfer !== null
        ? AwaitingTransfer.fromPartial(object.awaitingTransfer)
        : undefined;
    message.transferring =
      object.transferring !== undefined && object.transferring !== null
        ? Transferring.fromPartial(object.transferring)
        : undefined;
    message.swapping =
      object.swapping !== undefined && object.swapping !== null
        ? Swapping.fromPartial(object.swapping)
        : undefined;
    message.awaitingFill =
      object.awaitingFill !== undefined && object.awaitingFill !== null
        ? AwaitingFill.fromPartial(object.awaitingFill)
        : undefined;
    message.claimAvailable =
      object.claimAvailable !== undefined && object.claimAvailable !== null
        ? ClaimAvailable.fromPartial(object.claimAvailable)
        : undefined;
    message.refundAvailable =
      object.refundAvailable !== undefined && object.refundAvailable !== null
        ? RefundAvailable.fromPartial(object.refundAvailable)
        : undefined;
    message.receivingFunds =
      object.receivingFunds !== undefined && object.receivingFunds !== null
        ? ReceivingFunds.fromPartial(object.receivingFunds)
        : undefined;
    message.tradeSettled =
      object.tradeSettled !== undefined && object.tradeSettled !== null
        ? TradeSettled.fromPartial(object.tradeSettled)
        : undefined;
    message.keepAlive =
      object.keepAlive !== undefined && object.keepAlive !== null
        ? KeepAlive.fromPartial(object.keepAlive)
        : undefined;
    message.unsubscribed =
      object.unsubscribed !== undefined && object.unsubscribed !== null
        ? Unsubscribed.fromPartial(object.unsubscribed)
        : undefined;
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
