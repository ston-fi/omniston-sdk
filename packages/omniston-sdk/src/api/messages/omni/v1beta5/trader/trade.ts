// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.0
//   protoc               v5.28.3
// source: omni/v1beta5/trader/trade.proto

/* eslint-disable */
import { Address, KeepAlive } from "../types/common";

export const protobufPackage = "omni.v1beta5";

export const ChunkResult = {
  CHUNK_RESULT_PROCESSING: "CHUNK_RESULT_PROCESSING",
  CHUNK_RESULT_FILLED: "CHUNK_RESULT_FILLED",
  CHUNK_RESULT_ABORTED: "CHUNK_RESULT_ABORTED",
  UNRECOGNIZED: "UNRECOGNIZED",
} as const;

export type ChunkResult = (typeof ChunkResult)[keyof typeof ChunkResult];

export namespace ChunkResult {
  export type CHUNK_RESULT_PROCESSING =
    typeof ChunkResult.CHUNK_RESULT_PROCESSING;
  export type CHUNK_RESULT_FILLED = typeof ChunkResult.CHUNK_RESULT_FILLED;
  export type CHUNK_RESULT_ABORTED = typeof ChunkResult.CHUNK_RESULT_ABORTED;
  export type UNRECOGNIZED = typeof ChunkResult.UNRECOGNIZED;
}

export function chunkResultFromJSON(object: any): ChunkResult {
  switch (object) {
    case 0:
    case "CHUNK_RESULT_PROCESSING":
      return ChunkResult.CHUNK_RESULT_PROCESSING;
    case 1:
    case "CHUNK_RESULT_FILLED":
      return ChunkResult.CHUNK_RESULT_FILLED;
    case 2:
    case "CHUNK_RESULT_ABORTED":
      return ChunkResult.CHUNK_RESULT_ABORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChunkResult.UNRECOGNIZED;
  }
}

export function chunkResultToJSON(object: ChunkResult): number {
  switch (object) {
    case ChunkResult.CHUNK_RESULT_PROCESSING:
      return 0;
    case ChunkResult.CHUNK_RESULT_FILLED:
      return 1;
    case ChunkResult.CHUNK_RESULT_ABORTED:
      return 2;
    case ChunkResult.UNRECOGNIZED:
    default:
      return -1;
  }
}

export const TradeResult = {
  TRADE_RESULT_UNKNOWN: "TRADE_RESULT_UNKNOWN",
  TRADE_RESULT_FULLY_FILLED: "TRADE_RESULT_FULLY_FILLED",
  TRADE_RESULT_PARTIALLY_FILLED: "TRADE_RESULT_PARTIALLY_FILLED",
  TRADE_RESULT_ABORTED: "TRADE_RESULT_ABORTED",
  UNRECOGNIZED: "UNRECOGNIZED",
} as const;

export type TradeResult = (typeof TradeResult)[keyof typeof TradeResult];

export namespace TradeResult {
  export type TRADE_RESULT_UNKNOWN = typeof TradeResult.TRADE_RESULT_UNKNOWN;
  export type TRADE_RESULT_FULLY_FILLED =
    typeof TradeResult.TRADE_RESULT_FULLY_FILLED;
  export type TRADE_RESULT_PARTIALLY_FILLED =
    typeof TradeResult.TRADE_RESULT_PARTIALLY_FILLED;
  export type TRADE_RESULT_ABORTED = typeof TradeResult.TRADE_RESULT_ABORTED;
  export type UNRECOGNIZED = typeof TradeResult.UNRECOGNIZED;
}

export function tradeResultFromJSON(object: any): TradeResult {
  switch (object) {
    case 0:
    case "TRADE_RESULT_UNKNOWN":
      return TradeResult.TRADE_RESULT_UNKNOWN;
    case 1:
    case "TRADE_RESULT_FULLY_FILLED":
      return TradeResult.TRADE_RESULT_FULLY_FILLED;
    case 2:
    case "TRADE_RESULT_PARTIALLY_FILLED":
      return TradeResult.TRADE_RESULT_PARTIALLY_FILLED;
    case 3:
    case "TRADE_RESULT_ABORTED":
      return TradeResult.TRADE_RESULT_ABORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TradeResult.UNRECOGNIZED;
  }
}

export function tradeResultToJSON(object: TradeResult): number {
  switch (object) {
    case TradeResult.TRADE_RESULT_UNKNOWN:
      return 0;
    case TradeResult.TRADE_RESULT_FULLY_FILLED:
      return 1;
    case TradeResult.TRADE_RESULT_PARTIALLY_FILLED:
      return 2;
    case TradeResult.TRADE_RESULT_ABORTED:
      return 3;
    case TradeResult.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface ChunkStatus {
  /**
   * Address of the contract that processes this chunk.
   *
   * Generally, this address receives offer tokens.
   * More specifically, it might be the address of a protocol or liquidity pool.
   */
  targetAddress: Address | undefined;
  offerUnits: string;
  expectedAskUnits: string;
  actualAskUnits: string;
  result: ChunkResult;
  resultDetailsJson: string;
}

export interface StepStatus {
  chunks: ChunkStatus[];
}

export interface RouteStatus {
  steps: StepStatus[];
}

/** A request to track the status of specific trade */
export interface TrackTradeRequest {
  /** ID of the quote */
  quoteId: string;
  /** The address of trader's wallet that initiated transaction */
  traderWalletAddress: Address | undefined;
}

/**
 * Waiting for the trader to initiate the trade.
 * Getting this status means that the transaction initiating the trade hasn't appeared yet.
 */
export interface AwaitingTransfer {}

/** Initial transaction found, waiting for its mining. */
export interface Transferring {
  /** Hash of transaction that initiated the trade. */
  outgoingTxHash: string;
}

/**
 * Awaiting trade to fill.
 * For `SWAP`: awaiting swap transactions in the pools.
 * For `ESCROW` & `HTLC`: awaiting resolver's deposit
 */
export interface FillingTrade {
  /** Hash of transaction that initiated the trade. */
  outgoingTxHash: string;
  /** Info about partial filling of the trade. */
  routes: RouteStatus[];
}

/**
 * Specific to `HTLC` settlement. Resolver's deposit is claimable.
 * TODO: Think of joining Claims & Refunds in a single structure with multiple chunks.
 */
export interface ClaimAvailable {
  /** Address of HTLC contract with claimable deposit. */
  contractAddress: Address | undefined;
  /** Index of deposit within HTLC contract with claimable deposit. */
  depositIndex: number;
}

/** Specific to `ESCROW` & `HTLC` settlement. Deposit timeout has expired, need to refund it. */
export interface RefundAvailable {
  /** Address of escrow or HTLC contract that enforces the swap. */
  contractAddress: Address | undefined;
  /** Index of deposit within escrow or HTLC contract with refundable deposit. */
  depositIndex: number;
}

/** The transactions with incoming funds found, waiting for them to mine. */
export interface ReceivingFunds {
  /** Info about chunks of the trade. */
  routes: RouteStatus[];
}

/** The trade has completed (fully or partially filled or fully aborted) */
export interface TradeSettled {
  /** Result of the trade */
  result: TradeResult;
  /** Info about partial filling of the trade. */
  routes: RouteStatus[];
}

export interface TradeStatus {
  status: TradeStatus_StatusOneOf | undefined;
}

export interface TradeStatus_StatusOneOf {
  /** Waiting for the trader to initiate the trade. */
  awaitingTransfer?: AwaitingTransfer | undefined;
  /** Initial transaction found, waiting for transfer of funds to complete. */
  transferring?: Transferring | undefined;
  /**
   * Awaiting trade to fill.
   * For `SWAP`: awaiting swap transactions in the pools.
   * For `ESCROW` & `HTLC`: awaiting resolver's deposit.
   */
  fillingTrade?: FillingTrade | undefined;
  /** Specific to `HTLC` settlement. Resolver's deposit is claimable. */
  claimAvailable?: ClaimAvailable | undefined;
  /** Specific to `ESCROW` & `HTLC` settlement. Deposit timeout has expired, need to refund it */
  refundAvailable?: RefundAvailable | undefined;
  /** The transaction with incoming funds found, waiting for it to mine. */
  receivingFunds?: ReceivingFunds | undefined;
  /** The trade has completed (fully or partially filled or fully aborted) */
  tradeSettled?: TradeSettled | undefined;
  /** The service message to keep connection alive */
  keepAlive?: KeepAlive | undefined;
}

function createBaseChunkStatus(): ChunkStatus {
  return {
    targetAddress: undefined,
    offerUnits: "",
    expectedAskUnits: "",
    actualAskUnits: "",
    result: ChunkResult.CHUNK_RESULT_PROCESSING,
    resultDetailsJson: "",
  };
}

export const ChunkStatus = {
  fromJSON(object: any): ChunkStatus {
    return {
      targetAddress: isSet(object.target_address)
        ? Address.fromJSON(object.target_address)
        : undefined,
      offerUnits: isSet(object.offer_units)
        ? globalThis.String(object.offer_units)
        : "",
      expectedAskUnits: isSet(object.expected_ask_units)
        ? globalThis.String(object.expected_ask_units)
        : "",
      actualAskUnits: isSet(object.actual_ask_units)
        ? globalThis.String(object.actual_ask_units)
        : "",
      result: isSet(object.result)
        ? chunkResultFromJSON(object.result)
        : ChunkResult.CHUNK_RESULT_PROCESSING,
      resultDetailsJson: isSet(object.result_details_json)
        ? globalThis.String(object.result_details_json)
        : "",
    };
  },

  toJSON(message: ChunkStatus): unknown {
    const obj: any = {};
    if (message.targetAddress !== undefined) {
      obj.target_address = Address.toJSON(message.targetAddress);
    }
    if (message.offerUnits !== undefined) {
      obj.offer_units = message.offerUnits;
    }
    if (message.expectedAskUnits !== undefined) {
      obj.expected_ask_units = message.expectedAskUnits;
    }
    if (message.actualAskUnits !== undefined) {
      obj.actual_ask_units = message.actualAskUnits;
    }
    if (message.result !== undefined) {
      obj.result = chunkResultToJSON(message.result);
    }
    if (message.resultDetailsJson !== undefined) {
      obj.result_details_json = message.resultDetailsJson;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChunkStatus>, I>>(base?: I): ChunkStatus {
    return ChunkStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChunkStatus>, I>>(
    object: I,
  ): ChunkStatus {
    const message = createBaseChunkStatus();
    message.targetAddress =
      object.targetAddress !== undefined && object.targetAddress !== null
        ? Address.fromPartial(object.targetAddress)
        : undefined;
    message.offerUnits = object.offerUnits ?? "";
    message.expectedAskUnits = object.expectedAskUnits ?? "";
    message.actualAskUnits = object.actualAskUnits ?? "";
    message.result = object.result ?? ChunkResult.CHUNK_RESULT_PROCESSING;
    message.resultDetailsJson = object.resultDetailsJson ?? "";
    return message;
  },
};

function createBaseStepStatus(): StepStatus {
  return { chunks: [] };
}

export const StepStatus = {
  fromJSON(object: any): StepStatus {
    return {
      chunks: globalThis.Array.isArray(object?.chunks)
        ? object.chunks.map((e: any) => ChunkStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StepStatus): unknown {
    const obj: any = {};
    if (message.chunks?.length) {
      obj.chunks = message.chunks.map((e) => ChunkStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StepStatus>, I>>(base?: I): StepStatus {
    return StepStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StepStatus>, I>>(
    object: I,
  ): StepStatus {
    const message = createBaseStepStatus();
    message.chunks =
      object.chunks?.map((e) => ChunkStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRouteStatus(): RouteStatus {
  return { steps: [] };
}

export const RouteStatus = {
  fromJSON(object: any): RouteStatus {
    return {
      steps: globalThis.Array.isArray(object?.steps)
        ? object.steps.map((e: any) => StepStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RouteStatus): unknown {
    const obj: any = {};
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => StepStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteStatus>, I>>(base?: I): RouteStatus {
    return RouteStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RouteStatus>, I>>(
    object: I,
  ): RouteStatus {
    const message = createBaseRouteStatus();
    message.steps = object.steps?.map((e) => StepStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTrackTradeRequest(): TrackTradeRequest {
  return { quoteId: "", traderWalletAddress: undefined };
}

export const TrackTradeRequest = {
  fromJSON(object: any): TrackTradeRequest {
    return {
      quoteId: isSet(object.quote_id) ? globalThis.String(object.quote_id) : "",
      traderWalletAddress: isSet(object.trader_wallet_address)
        ? Address.fromJSON(object.trader_wallet_address)
        : undefined,
    };
  },

  toJSON(message: TrackTradeRequest): unknown {
    const obj: any = {};
    if (message.quoteId !== undefined) {
      obj.quote_id = message.quoteId;
    }
    if (message.traderWalletAddress !== undefined) {
      obj.trader_wallet_address = Address.toJSON(message.traderWalletAddress);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackTradeRequest>, I>>(
    base?: I,
  ): TrackTradeRequest {
    return TrackTradeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackTradeRequest>, I>>(
    object: I,
  ): TrackTradeRequest {
    const message = createBaseTrackTradeRequest();
    message.quoteId = object.quoteId ?? "";
    message.traderWalletAddress =
      object.traderWalletAddress !== undefined &&
      object.traderWalletAddress !== null
        ? Address.fromPartial(object.traderWalletAddress)
        : undefined;
    return message;
  },
};

function createBaseAwaitingTransfer(): AwaitingTransfer {
  return {};
}

export const AwaitingTransfer = {
  fromJSON(_: any): AwaitingTransfer {
    return {};
  },

  toJSON(_: AwaitingTransfer): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AwaitingTransfer>, I>>(
    base?: I,
  ): AwaitingTransfer {
    return AwaitingTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AwaitingTransfer>, I>>(
    _: I,
  ): AwaitingTransfer {
    const message = createBaseAwaitingTransfer();
    return message;
  },
};

function createBaseTransferring(): Transferring {
  return { outgoingTxHash: "" };
}

export const Transferring = {
  fromJSON(object: any): Transferring {
    return {
      outgoingTxHash: isSet(object.outgoing_tx_hash)
        ? globalThis.String(object.outgoing_tx_hash)
        : "",
    };
  },

  toJSON(message: Transferring): unknown {
    const obj: any = {};
    if (message.outgoingTxHash !== undefined) {
      obj.outgoing_tx_hash = message.outgoingTxHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transferring>, I>>(
    base?: I,
  ): Transferring {
    return Transferring.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transferring>, I>>(
    object: I,
  ): Transferring {
    const message = createBaseTransferring();
    message.outgoingTxHash = object.outgoingTxHash ?? "";
    return message;
  },
};

function createBaseFillingTrade(): FillingTrade {
  return { outgoingTxHash: "", routes: [] };
}

export const FillingTrade = {
  fromJSON(object: any): FillingTrade {
    return {
      outgoingTxHash: isSet(object.outgoing_tx_hash)
        ? globalThis.String(object.outgoing_tx_hash)
        : "",
      routes: globalThis.Array.isArray(object?.routes)
        ? object.routes.map((e: any) => RouteStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FillingTrade): unknown {
    const obj: any = {};
    if (message.outgoingTxHash !== undefined) {
      obj.outgoing_tx_hash = message.outgoingTxHash;
    }
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => RouteStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FillingTrade>, I>>(
    base?: I,
  ): FillingTrade {
    return FillingTrade.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FillingTrade>, I>>(
    object: I,
  ): FillingTrade {
    const message = createBaseFillingTrade();
    message.outgoingTxHash = object.outgoingTxHash ?? "";
    message.routes =
      object.routes?.map((e) => RouteStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClaimAvailable(): ClaimAvailable {
  return { contractAddress: undefined, depositIndex: 0 };
}

export const ClaimAvailable = {
  fromJSON(object: any): ClaimAvailable {
    return {
      contractAddress: isSet(object.contract_address)
        ? Address.fromJSON(object.contract_address)
        : undefined,
      depositIndex: isSet(object.deposit_index)
        ? globalThis.Number(object.deposit_index)
        : 0,
    };
  },

  toJSON(message: ClaimAvailable): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contract_address = Address.toJSON(message.contractAddress);
    }
    if (message.depositIndex !== undefined) {
      obj.deposit_index = Math.round(message.depositIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimAvailable>, I>>(
    base?: I,
  ): ClaimAvailable {
    return ClaimAvailable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimAvailable>, I>>(
    object: I,
  ): ClaimAvailable {
    const message = createBaseClaimAvailable();
    message.contractAddress =
      object.contractAddress !== undefined && object.contractAddress !== null
        ? Address.fromPartial(object.contractAddress)
        : undefined;
    message.depositIndex = object.depositIndex ?? 0;
    return message;
  },
};

function createBaseRefundAvailable(): RefundAvailable {
  return { contractAddress: undefined, depositIndex: 0 };
}

export const RefundAvailable = {
  fromJSON(object: any): RefundAvailable {
    return {
      contractAddress: isSet(object.contract_address)
        ? Address.fromJSON(object.contract_address)
        : undefined,
      depositIndex: isSet(object.deposit_index)
        ? globalThis.Number(object.deposit_index)
        : 0,
    };
  },

  toJSON(message: RefundAvailable): unknown {
    const obj: any = {};
    if (message.contractAddress !== undefined) {
      obj.contract_address = Address.toJSON(message.contractAddress);
    }
    if (message.depositIndex !== undefined) {
      obj.deposit_index = Math.round(message.depositIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefundAvailable>, I>>(
    base?: I,
  ): RefundAvailable {
    return RefundAvailable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefundAvailable>, I>>(
    object: I,
  ): RefundAvailable {
    const message = createBaseRefundAvailable();
    message.contractAddress =
      object.contractAddress !== undefined && object.contractAddress !== null
        ? Address.fromPartial(object.contractAddress)
        : undefined;
    message.depositIndex = object.depositIndex ?? 0;
    return message;
  },
};

function createBaseReceivingFunds(): ReceivingFunds {
  return { routes: [] };
}

export const ReceivingFunds = {
  fromJSON(object: any): ReceivingFunds {
    return {
      routes: globalThis.Array.isArray(object?.routes)
        ? object.routes.map((e: any) => RouteStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReceivingFunds): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => RouteStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReceivingFunds>, I>>(
    base?: I,
  ): ReceivingFunds {
    return ReceivingFunds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReceivingFunds>, I>>(
    object: I,
  ): ReceivingFunds {
    const message = createBaseReceivingFunds();
    message.routes =
      object.routes?.map((e) => RouteStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTradeSettled(): TradeSettled {
  return { result: TradeResult.TRADE_RESULT_UNKNOWN, routes: [] };
}

export const TradeSettled = {
  fromJSON(object: any): TradeSettled {
    return {
      result: isSet(object.result)
        ? tradeResultFromJSON(object.result)
        : TradeResult.TRADE_RESULT_UNKNOWN,
      routes: globalThis.Array.isArray(object?.routes)
        ? object.routes.map((e: any) => RouteStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TradeSettled): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = tradeResultToJSON(message.result);
    }
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => RouteStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TradeSettled>, I>>(
    base?: I,
  ): TradeSettled {
    return TradeSettled.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TradeSettled>, I>>(
    object: I,
  ): TradeSettled {
    const message = createBaseTradeSettled();
    message.result = object.result ?? TradeResult.TRADE_RESULT_UNKNOWN;
    message.routes =
      object.routes?.map((e) => RouteStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTradeStatus(): TradeStatus {
  return { status: undefined };
}

export const TradeStatus = {
  fromJSON(object: any): TradeStatus {
    return {
      status: isSet(object.status)
        ? TradeStatus_StatusOneOf.fromJSON(object.status)
        : undefined,
    };
  },

  toJSON(message: TradeStatus): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = TradeStatus_StatusOneOf.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TradeStatus>, I>>(base?: I): TradeStatus {
    return TradeStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TradeStatus>, I>>(
    object: I,
  ): TradeStatus {
    const message = createBaseTradeStatus();
    message.status =
      object.status !== undefined && object.status !== null
        ? TradeStatus_StatusOneOf.fromPartial(object.status)
        : undefined;
    return message;
  },
};

function createBaseTradeStatus_StatusOneOf(): TradeStatus_StatusOneOf {
  return {
    awaitingTransfer: undefined,
    transferring: undefined,
    fillingTrade: undefined,
    claimAvailable: undefined,
    refundAvailable: undefined,
    receivingFunds: undefined,
    tradeSettled: undefined,
    keepAlive: undefined,
  };
}

export const TradeStatus_StatusOneOf = {
  fromJSON(object: any): TradeStatus_StatusOneOf {
    return {
      awaitingTransfer: isSet(object.awaiting_transfer)
        ? AwaitingTransfer.fromJSON(object.awaiting_transfer)
        : undefined,
      transferring: isSet(object.transferring)
        ? Transferring.fromJSON(object.transferring)
        : undefined,
      fillingTrade: isSet(object.filling_trade)
        ? FillingTrade.fromJSON(object.filling_trade)
        : undefined,
      claimAvailable: isSet(object.claim_available)
        ? ClaimAvailable.fromJSON(object.claim_available)
        : undefined,
      refundAvailable: isSet(object.refund_available)
        ? RefundAvailable.fromJSON(object.refund_available)
        : undefined,
      receivingFunds: isSet(object.receiving_funds)
        ? ReceivingFunds.fromJSON(object.receiving_funds)
        : undefined,
      tradeSettled: isSet(object.trade_settled)
        ? TradeSettled.fromJSON(object.trade_settled)
        : undefined,
      keepAlive: isSet(object.keep_alive)
        ? KeepAlive.fromJSON(object.keep_alive)
        : undefined,
    };
  },

  toJSON(message: TradeStatus_StatusOneOf): unknown {
    const obj: any = {};
    if (message.awaitingTransfer !== undefined) {
      obj.awaiting_transfer = AwaitingTransfer.toJSON(message.awaitingTransfer);
    }
    if (message.transferring !== undefined) {
      obj.transferring = Transferring.toJSON(message.transferring);
    }
    if (message.fillingTrade !== undefined) {
      obj.filling_trade = FillingTrade.toJSON(message.fillingTrade);
    }
    if (message.claimAvailable !== undefined) {
      obj.claim_available = ClaimAvailable.toJSON(message.claimAvailable);
    }
    if (message.refundAvailable !== undefined) {
      obj.refund_available = RefundAvailable.toJSON(message.refundAvailable);
    }
    if (message.receivingFunds !== undefined) {
      obj.receiving_funds = ReceivingFunds.toJSON(message.receivingFunds);
    }
    if (message.tradeSettled !== undefined) {
      obj.trade_settled = TradeSettled.toJSON(message.tradeSettled);
    }
    if (message.keepAlive !== undefined) {
      obj.keep_alive = KeepAlive.toJSON(message.keepAlive);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TradeStatus_StatusOneOf>, I>>(
    base?: I,
  ): TradeStatus_StatusOneOf {
    return TradeStatus_StatusOneOf.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TradeStatus_StatusOneOf>, I>>(
    object: I,
  ): TradeStatus_StatusOneOf {
    const message = createBaseTradeStatus_StatusOneOf();
    message.awaitingTransfer =
      object.awaitingTransfer !== undefined && object.awaitingTransfer !== null
        ? AwaitingTransfer.fromPartial(object.awaitingTransfer)
        : undefined;
    message.transferring =
      object.transferring !== undefined && object.transferring !== null
        ? Transferring.fromPartial(object.transferring)
        : undefined;
    message.fillingTrade =
      object.fillingTrade !== undefined && object.fillingTrade !== null
        ? FillingTrade.fromPartial(object.fillingTrade)
        : undefined;
    message.claimAvailable =
      object.claimAvailable !== undefined && object.claimAvailable !== null
        ? ClaimAvailable.fromPartial(object.claimAvailable)
        : undefined;
    message.refundAvailable =
      object.refundAvailable !== undefined && object.refundAvailable !== null
        ? RefundAvailable.fromPartial(object.refundAvailable)
        : undefined;
    message.receivingFunds =
      object.receivingFunds !== undefined && object.receivingFunds !== null
        ? ReceivingFunds.fromPartial(object.receivingFunds)
        : undefined;
    message.tradeSettled =
      object.tradeSettled !== undefined && object.tradeSettled !== null
        ? TradeSettled.fromPartial(object.tradeSettled)
        : undefined;
    message.keepAlive =
      object.keepAlive !== undefined && object.keepAlive !== null
        ? KeepAlive.fromPartial(object.keepAlive)
        : undefined;
    return message;
  },
};

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
